package core

import (
	"context"
	"encoding/json"
	"sync"
	"sync/atomic"

	"github.com/coder/websocket"
	"github.com/ksysoev/wasabi"
)

const (
	// initID is the initial ID for the connection.
	// it uses a large number to avoid conflicts with the IDs generated by the frontend.
	// not solving the problem fully, but it's a good start.
	initID int64 = 1_000_000
)

type Conn struct {
	clientConn wasabi.Connection
	requests   map[int64]chan []byte
	onClose    func(string)
	currID     int64
	mu         sync.Mutex
}

// NewConnection initializes a new Conn instance with the provided wasabi.Connection and onClose callback.
// It takes conn of type wasabi.Connection and onClose of type func(id string).
// It returns a pointer to a Conn struct.
// It panics if conn is nil.
func NewConnection(conn wasabi.Connection, onClose func(id string)) *Conn {
	if conn == nil {
		panic("conn is nil")
	}

	return &Conn{
		clientConn: conn,
		currID:     initID,
		requests:   make(map[int64]chan []byte),
		onClose:    onClose,
	}
}

// ID returns the unique identifier of the connection.
// It returns a string which is the ID of the client connection.
func (c *Conn) ID() string {
	return c.clientConn.ID()
}

// Context returns the context associated with the Conn instance.
// It returns a context.Context which is the context of the underlying client connection.
func (c *Conn) Context() context.Context {
	return c.clientConn.Context()
}

// WaitResponse waits for a response from the connection and returns a request ID and a channel to receive the response.
// It returns an int64 representing the request ID and a receive-only channel of type []byte for the response.
func (c *Conn) WaitResponse() (reqID int64, respChan <-chan []byte) {
	c.mu.Lock()
	defer c.mu.Unlock()

	reqID = c.nextID()
	ch := make(chan []byte, 1)
	c.requests[reqID] = ch

	return reqID, ch
}

// nextID generates the next unique identifier for the connection.
// It increments the current ID atomically to ensure thread safety.
// It returns an int64 which is the next unique identifier.
func (c *Conn) nextID() int64 {
	return atomic.AddInt64(&c.currID, 1)
}

// Send sends a message of the specified type through the connection.
// It takes msgType of type wasabi.MessageType and msg of type []byte.
// It returns an error if the message cannot be unmarshaled into the expected format or if there is an issue sending the message.
// If the message type is binary, it sends the message directly.
// If the message contains a req_id, it handles the request-response mechanism by sending the message to the appropriate channel.
func (c *Conn) Send(msgType wasabi.MessageType, msg []byte) error {
	if msgType == wasabi.MsgTypeBinary {
		return c.clientConn.Send(msgType, msg)
	}

	var respID struct {
		ReqID int64 `json:"req_id"`
	}

	if err := json.Unmarshal(msg, &respID); err != nil {
		return c.clientConn.Send(msgType, msg)
	}

	if respID.ReqID == 0 {
		return c.clientConn.Send(msgType, msg)
	}

	if !c.DoneRequest(respID.ReqID, msg) {
		return c.clientConn.Send(msgType, msg)
	}

	return nil
}

func (c *Conn) DoneRequest(reqID int64, resp []byte) bool {
	c.mu.Lock()
	ch, ok := c.requests[reqID]
	delete(c.requests, reqID)
	c.mu.Unlock()

	if !ok {
		return false
	}

	ch <- resp

	return true
}

// Close terminates the connection with a given status code and reason.
// It takes a status of type websocket.StatusCode, a reason of type string, and an optional closingCtx of type context.Context.
// It returns an error if the connection closure fails.
func (c *Conn) Close(status websocket.StatusCode, reason string, closingCtx ...context.Context) error {
	c.onClose(c.ID())
	return c.clientConn.Close(status, reason, closingCtx...)
}
